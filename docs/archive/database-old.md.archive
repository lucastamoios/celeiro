# Database Architecture - Celeiro

## Diagrama ER (Entity Relationship)

```mermaid
erDiagram
    users ||--o{ accounts : "owns"
    users ||--o{ budgets : "creates"
    users ||--o{ categories : "creates"
    users ||--o{ classification_rules : "defines"
    
    accounts ||--o{ transactions : "has"
    accounts {
        serial account_id PK
        int user_id FK
        string name "Nome da conta"
        string account_type "checking/savings/credit"
        timestamp created_at
        timestamp updated_at
    }
    
    transactions ||--o| categories : "belongs_to"
    transactions {
        serial transaction_id PK
        int account_id FK
        int category_id FK "nullable - não classificada inicialmente"
        string description "Descrição do OFX"
        decimal amount "Valor (negativo = débito, positivo = crédito)"
        date transaction_date "Data da transação"
        string transaction_type "debit/credit"
        boolean is_classified "Flag de performance"
        string ofx_fitid "Unique per account - evita duplicatas"
        jsonb raw_ofx_data "Dados brutos do OFX para auditoria"
        timestamp created_at
        timestamp updated_at
    }
    
    categories ||--o{ budgets : "has_budget"
    categories {
        serial category_id PK
        int user_id FK
        string name "Nome da categoria"
        string icon "Emoji ou código icon"
        string color "Hex color para UI"
        boolean is_system "true para categorias default"
        timestamp created_at
        timestamp updated_at
    }
    
    budgets ||--o{ budget_items : "contains"
    budgets {
        serial budget_id PK
        int user_id FK
        int category_id FK
        int month "1-12"
        int year "YYYY"
        decimal amount "Valor fixo do orçamento (nullable se calculado)"
        string budget_type "fixed/calculated/hybrid"
        timestamp created_at
        timestamp updated_at
    }
    
    budget_items {
        serial budget_item_id PK
        int budget_id FK
        string description "Ex: Netflix, Spotify"
        decimal amount "Valor previsto"
        timestamp created_at
        timestamp updated_at
    }
    
    classification_rules {
        serial rule_id PK
        int user_id FK
        int category_id FK
        string rule_type "description/amount/date/combined"
        string pattern "Regex ou string de comparação"
        jsonb conditions "Estrutura JSON para regras complexas"
        int priority "Lower = executa primeiro"
        boolean is_active "Permite desabilitar sem deletar"
        timestamp created_at
        timestamp updated_at
    }
    
    users {
        serial user_id PK
        string email "Unique"
        string name
        string password_hash
        timestamp created_at
        timestamp updated_at
    }
```

## Decisões de Design

### 1. Transactions

#### FITID como Unique Constraint
```sql
UNIQUE (account_id, ofx_fitid)
```

**Por quê:** 
- Bancos garantem FITID único dentro da conta
- Permite re-importação sem duplicatas
- `INSERT ... ON CONFLICT DO NOTHING` fica eficiente

#### Amount como Decimal
```sql
amount DECIMAL(12, 2) NOT NULL
```

**Por quê:**
- Precisão exata (não usar FLOAT pra dinheiro!)
- 12 dígitos totais, 2 decimais = até R$ 9.999.999.999,99
- Negativo = débito, Positivo = crédito

#### Raw OFX como JSONB
```sql
raw_ofx_data JSONB
```

**Por quê:**
- Mantém dados originais sem perda
- Permite queries se necessário (`WHERE raw_ofx_data->>'memo' = 'X'`)
- Auditoria e debug (ver XML original)

#### is_classified Flag
```sql
is_classified BOOLEAN DEFAULT FALSE
```

**Por quê:**
- Performance: `WHERE is_classified = false` é instant com índice
- Alternativa: `WHERE category_id IS NULL` seria mais lento em tabelas grandes

### 2. Categories

#### System vs User Categories
```sql
is_system BOOLEAN DEFAULT FALSE
```

**Categorias system (is_system = true):**
- Alimentação
- Transporte
- Moradia
- Saúde
- Educação
- Lazer
- Outros

**Regras:**
- System categories não podem ser deletadas
- User categories podem ser criadas/editadas/deletadas livremente
- Migração inicial cria as 7 categorias system

### 3. Budgets

#### Budget Type Enum
```go
type BudgetType string

const (
    BudgetTypeFixed      BudgetType = "fixed"      // amount definido pelo usuário
    BudgetTypeCalculated BudgetType = "calculated" // sum(budget_items.amount)
    BudgetTypeHybrid     BudgetType = "hybrid"     // max(amount, sum(items))
)
```

**Lógica de cálculo:**
```go
func (b *Budget) CalculateFinalAmount() decimal.Decimal {
    itemsSum := b.CalculateItemsSum()
    
    switch b.Type {
    case BudgetTypeFixed:
        return b.Amount
    case BudgetTypeCalculated:
        return itemsSum
    case BudgetTypeHybrid:
        return max(b.Amount, itemsSum)
    }
}
```

#### Orçamento Ausente
**Regra de negócio:** Se não existe budget para categoria no mês:
1. Busca valor **real** do mês anterior (sum de transactions)
2. Se não tem mês anterior, retorna 0

```sql
-- Query para pegar orçamento efetivo
WITH previous_month_spent AS (
    SELECT COALESCE(SUM(amount), 0) as spent
    FROM transactions
    WHERE category_id = $1
      AND DATE_TRUNC('month', transaction_date) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
)
SELECT COALESCE(
    (SELECT calculate_budget_amount(budget_id) FROM budgets WHERE ...),
    (SELECT spent FROM previous_month_spent),
    0
) as effective_budget;
```

### 4. Classification Rules

#### Conditions JSONB Structure

**Exemplo - Regra por descrição:**
```json
{
  "type": "description",
  "pattern": "IFOOD|RAPPI|UBER.*EATS",
  "match_type": "regex"
}
```

**Exemplo - Regra por valor:**
```json
{
  "type": "amount",
  "min": 10.00,
  "max": 200.00
}
```

**Exemplo - Regra combinada (AND):**
```json
{
  "type": "combined",
  "operator": "AND",
  "rules": [
    {
      "type": "description",
      "pattern": "POSTO",
      "match_type": "contains"
    },
    {
      "type": "amount",
      "min": 50.00,
      "max": 500.00
    }
  ]
}
```

#### Priority Execution
```sql
SELECT * FROM classification_rules
WHERE user_id = $1 AND is_active = true
ORDER BY priority ASC, created_at ASC
```

**Lógica:**
1. Pega transação não classificada
2. Roda todas as regras em ordem de prioridade
3. Primeira que bater, atribui categoria
4. Para execução (não testa outras regras)

## Índices Críticos

### Performance Queries

```sql
-- Transactions: Query principal (lista por conta + data)
CREATE INDEX idx_transactions_account_date 
ON transactions(account_id, transaction_date DESC);

-- Transactions: Busca de não classificadas
CREATE INDEX idx_transactions_unclassified 
ON transactions(account_id) 
WHERE is_classified = false;

-- Transactions: Agregações mensais por categoria
CREATE INDEX idx_transactions_category_month 
ON transactions(category_id, DATE_TRUNC('month', transaction_date));

-- Transactions: Evita duplicatas (unique constraint + performance)
CREATE UNIQUE INDEX idx_transactions_ofx_fitid 
ON transactions(account_id, ofx_fitid);

-- Budgets: Lookup de orçamento por mês
CREATE INDEX idx_budgets_user_month 
ON budgets(user_id, year, month);

-- Budgets: Agregações por categoria
CREATE INDEX idx_budgets_category 
ON budgets(category_id, year DESC, month DESC);

-- Classification Rules: Execução ordenada
CREATE INDEX idx_rules_active_priority 
ON classification_rules(user_id, priority ASC) 
WHERE is_active = true;
```

### Análise de Impacto

**Tabela crescerá mais:** `transactions`
- 100 transações/mês = 1.200/ano
- Após 5 anos = ~6.000 rows por usuário
- Com 1.000 usuários = 6.000.000 rows

**Queries que precisam ser rápidas:**
1. Lista transações não classificadas (tela de importação)
2. Dashboard mensal (sum por categoria)
3. Busca de transações (filtros múltiplos)

**Particionamento futuro (se > 10M rows):**
- Particionar por `transaction_date` (monthly partitions)
- Ou por `account_id` se multi-tenant

## Constraints e Validações

### Database Level

```sql
-- Users
ALTER TABLE users ADD CONSTRAINT users_email_valid 
  CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$');

-- Accounts
ALTER TABLE accounts ADD CONSTRAINT accounts_type_valid 
  CHECK (account_type IN ('checking', 'savings', 'credit'));

-- Transactions
ALTER TABLE transactions ADD CONSTRAINT transactions_type_valid 
  CHECK (transaction_type IN ('debit', 'credit'));

-- Budgets
ALTER TABLE budgets ADD CONSTRAINT budgets_month_valid 
  CHECK (month BETWEEN 1 AND 12);

ALTER TABLE budgets ADD CONSTRAINT budgets_year_valid 
  CHECK (year BETWEEN 2000 AND 2100);

ALTER TABLE budgets ADD CONSTRAINT budgets_type_valid 
  CHECK (budget_type IN ('fixed', 'calculated', 'hybrid'));

-- Budget Items
ALTER TABLE budget_items ADD CONSTRAINT budget_items_amount_positive 
  CHECK (amount > 0);

-- Classification Rules
ALTER TABLE classification_rules ADD CONSTRAINT rules_priority_positive 
  CHECK (priority >= 0);
```

### Application Level (Go)

```go
// Validar FITID único antes de insert
func (r *TransactionRepository) BulkInsert(ctx context.Context, txs []*Transaction) error {
    query := `
        INSERT INTO transactions (...)
        VALUES (:account_id, :ofx_fitid, ...)
        ON CONFLICT (account_id, ofx_fitid) DO NOTHING
        RETURNING transaction_id
    `
    // ...
}

// Validar budget amount baseado no tipo
func (b *Budget) Validate() error {
    if b.Type == BudgetTypeFixed && b.Amount.IsZero() {
        return errors.New("fixed budget requires amount")
    }
    return nil
}
```

## Migration Strategy

### Ordem de Criação (dependências)

1. `20250101000001_create_users.sql`
2. `20250101000002_create_categories.sql` (seed system categories)
3. `20250101000003_create_accounts.sql`
4. `20250101000004_create_transactions.sql`
5. `20250101000005_create_budgets.sql`
6. `20250101000006_create_budget_items.sql`
7. `20250101000007_create_classification_rules.sql`
8. `20250101000008_create_indexes.sql`

### Rollback Safety

Cada migration tem `-- +goose Down` correspondente:
```sql
-- +goose Up
CREATE TABLE transactions (...);

-- +goose Down
DROP TABLE IF EXISTS transactions CASCADE;
```

**Atenção:** `CASCADE` dropa constraints dependentes automaticamente.

## Queries Comuns (Referência)

### Dashboard Mensal
```sql
SELECT 
    c.name as category_name,
    COALESCE(SUM(t.amount), 0) as total_spent,
    b.calculated_amount as budgeted
FROM categories c
LEFT JOIN transactions t ON t.category_id = c.category_id
    AND DATE_TRUNC('month', t.transaction_date) = DATE_TRUNC('month', CURRENT_DATE)
LEFT JOIN budgets b ON b.category_id = c.category_id
    AND b.month = EXTRACT(MONTH FROM CURRENT_DATE)
    AND b.year = EXTRACT(YEAR FROM CURRENT_DATE)
WHERE c.user_id = $1
GROUP BY c.category_id, c.name, b.calculated_amount;
```

### Transações Não Classificadas
```sql
SELECT * FROM transactions
WHERE account_id = $1
  AND is_classified = false
ORDER BY transaction_date DESC
LIMIT 100;
```

### Aplicar Regra de Classificação
```sql
-- 1. Buscar regra aplicável
SELECT rule_id, category_id, conditions
FROM classification_rules
WHERE user_id = $1 AND is_active = true
ORDER BY priority ASC;

-- 2. Atualizar transação
UPDATE transactions
SET category_id = $1, is_classified = true
WHERE transaction_id = $2;
```

### Budget com Items
```sql
SELECT 
    b.*,
    COALESCE(SUM(bi.amount), 0) as items_sum
FROM budgets b
LEFT JOIN budget_items bi ON bi.budget_id = b.budget_id
WHERE b.budget_id = $1
GROUP BY b.budget_id;
```

## Backup & Recovery

### Backup Diário (Produção)
```bash
# Dump completo
pg_dump -h localhost -U celeiro -d celeiro -F c -f backup_$(date +%Y%m%d).dump

# Dump apenas schema
pg_dump -h localhost -U celeiro -d celeiro --schema-only -f schema.sql

# Dump apenas dados
pg_dump -h localhost -U celeiro -d celeiro --data-only -f data.sql
```

### Restore
```bash
# Restaurar dump completo
pg_restore -h localhost -U celeiro -d celeiro_restored -v backup_20250101.dump

# Restaurar apenas uma tabela
pg_restore -h localhost -U celeiro -d celeiro -t transactions backup.dump
```

## Performance Monitoring

### Queries Lentas
```sql
-- Ver queries mais lentas (requer pg_stat_statements)
SELECT 
    query,
    calls,
    total_exec_time / 1000 as total_seconds,
    mean_exec_time / 1000 as mean_seconds
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 10;
```

### Índices Não Utilizados
```sql
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
  AND indexrelname NOT LIKE '%_pkey'
ORDER BY pg_relation_size(indexrelid) DESC;
```

### Table Bloat
```sql
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

